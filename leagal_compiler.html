<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legal Compiler for AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Lichess / Dark Mode Theme */
        body { background-color: #161512; color: #bababa; font-family: 'Noto Sans JP', sans-serif; }
        .lichess-card { background-color: #262421; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .active-zone { background-color: #2b3036; border-color: #3692e7 !important; }
        .text-accent { color: #3692e7; }
        .border-accent { border-color: #3692e7; }
        .hover-card:hover { border-color: #606060; }
        
        /* Terminal / Log Styling */
        .terminal-font { font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', 'Droid Sans Mono', 'Source Code Pro', monospace; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #161512; }
        ::-webkit-scrollbar-thumb { background: #404040; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #505050; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Core Logic: XML Parsing (v5 Deep Structure) ---
        const ERA_MAP = { "Meiji": "明治", "Taisho": "大正", "Showa": "昭和", "Heisei": "平成", "Reiwa": "令和" };

        const parseLegalXML = (xmlText) => {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            
            const lawTitle = xmlDoc.querySelector('LawTitle')?.textContent || "Unknown_Law";
            const lawNum = xmlDoc.querySelector('LawNum')?.textContent || "";
            
            let enactDate = "";
            const lawTag = xmlDoc.querySelector('Law');
            if (lawTag && lawTag.getAttribute('Era')) {
                const eraRaw = lawTag.getAttribute('Era');
                const era = ERA_MAP[eraRaw] || eraRaw;
                enactDate = `${era}${lawTag.getAttribute('Year')}年${lawTag.getAttribute('PromulgateMonth')}月${lawTag.getAttribute('PromulgateDay')}日公布`;
            }

            let md = `---
title: "${lawTitle}"
law_num: "${lawNum}"
enact_date: "${enactDate}"
source_type: "xml_converted"
---\n\n# ${lawTitle}\n\n`;

            const clean = (t) => t ? t.replace(/\s+/g, ' ').trim() : '';
            const getSiblingIndex = (node, tag) => {
                let count = 1, prev = node.previousElementSibling;
                while(prev) { if(prev.nodeName === tag) count++; prev = prev.previousElementSibling; }
                return count;
            };

            const traverse = (node) => {
                if (!node) return;
                const name = node.nodeName;

                if (name === 'Part') md += `\n## ${node.querySelector('PartTitle')?.textContent || ''}\n\n`;
                else if (name === 'Chapter') md += `\n### ${node.querySelector('ChapterTitle')?.textContent || ''}\n\n`;
                else if (name === 'Section') md += `\n#### ${node.querySelector('SectionTitle')?.textContent || ''}\n\n`;
                else if (name === 'Article') {
                    const title = node.querySelector('ArticleTitle')?.textContent || '';
                    const caption = node.querySelector('ArticleCaption')?.textContent || '';
                    md += `\n##### ${title} ${caption}\n`;
                } else if (name === 'Paragraph') {
                    let num = node.querySelector('ParagraphNum')?.textContent?.trim();
                    if (!num) num = getSiblingIndex(node, 'Paragraph');
                    const sentence = node.querySelector('ParagraphSentence > Sentence')?.textContent || '';
                    md += `**第${num}項** ${clean(sentence)}\n\n`;
                } else if (name === 'Item') {
                    const num = node.querySelector('ItemTitle')?.textContent || '';
                    const sentence = node.querySelector('ItemSentence > Sentence')?.textContent || '';
                    md += `- **第${num}号** ${clean(sentence)}\n`;
                } else if (name === 'Subitem1') {
                    const num = node.querySelector('Subitem1Title')?.textContent || '';
                    const sentence = node.querySelector('Subitem1Sentence > Sentence')?.textContent || '';
                    md += `  - **${num}** ${clean(sentence)}\n`; 
                } else if (name === 'Subitem2') {
                    const num = node.querySelector('Subitem2Title')?.textContent || '';
                    const sentence = node.querySelector('Subitem2Sentence > Sentence')?.textContent || '';
                    md += `    - **${num}** ${clean(sentence)}\n`;
                }

                Array.from(node.children).forEach(child => {
                    if (!['PartTitle','ChapterTitle','SectionTitle','ArticleTitle','ArticleCaption','ParagraphNum','ParagraphSentence','ItemTitle','ItemSentence','Subitem1Title','Subitem1Sentence','Subitem2Title','Subitem2Sentence'].includes(child.nodeName)) {
                        traverse(child);
                    }
                });
            };

            const mainProvision = xmlDoc.querySelector('MainProvision');
            if (mainProvision) traverse(mainProvision);

            return { title: lawTitle, content: md };
        };

        // --- UI Component ---
        const App = () => {
            const [logs, setLogs] = useState([]);
            const [processing, setProcessing] = useState(false);
            const [isDragging, setIsDragging] = useState(false);
            const fileInputRef = useRef(null);

            const addLog = (msg) => setLogs(prev => [...prev.slice(-5), msg]); // Keep last 6 lines

            const handleFiles = async (fileList) => {
                setProcessing(true);
                setLogs([]);
                const outputZip = new JSZip();
                let processedCount = 0;

                try {
                    addLog("Initializing compiler...");
                    for (const file of fileList) {
                        if (file.name.endsWith('.zip')) {
                            addLog(`Reading archive: ${file.name}`);
                            const loadedZip = await JSZip.loadAsync(file);
                            const xmlFiles = Object.keys(loadedZip.files).filter(n => n.endsWith('.xml'));
                            for (const xmlPath of xmlFiles) {
                                const xmlText = await loadedZip.files[xmlPath].async("text");
                                const { title, content } = parseLegalXML(xmlText);
                                const safeName = title.replace(/[\\/:*?"<>|]/g, '_');
                                outputZip.file(`${safeName}.md`, content);
                                processedCount++;
                                addLog(`Compiled: ${title}`);
                            }
                        } else if (file.name.endsWith('.xml')) {
                            const xmlText = await file.text();
                            const { title, content } = parseLegalXML(xmlText);
                            const safeName = title.replace(/[\\/:*?"<>|]/g, '_');
                            outputZip.file(`${safeName}.md`, content);
                            processedCount++;
                            addLog(`Compiled: ${title}`);
                        }
                    }

                    if (processedCount > 0) {
                        addLog(`Building artifacts...`);
                        const content = await outputZip.generateAsync({ type: "blob" });
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(content);
                        a.download = `Legal_Artifacts_${new Date().toISOString().slice(0,10)}.zip`;
                        a.click();
                        addLog("Build success. Downloading.");
                    } else {
                        addLog("Error: No valid sources found.");
                    }
                } catch (e) {
                    addLog(`Fatal Error: ${e.message}`);
                    console.error(e);
                } finally {
                    setProcessing(false);
                }
            };

            useEffect(() => { lucide.createIcons(); }, [logs]);

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-6">
                    <div className="w-full max-w-lg">
                        
                        {/* Header */}
                        <header className="flex items-center space-x-3 mb-6 select-none opacity-90">
                            <i data-lucide="cpu" className="w-6 h-6 text-accent"></i>
                            <h1 className="text-xl font-light tracking-wide text-[#bababa]">Legal <span className="text-accent font-normal">Compiler</span></h1>
                        </header>

                        {/* Drop Zone */}
                        <div 
                            className={`lichess-card p-12 text-center border-2 border-dashed transition-all duration-200 cursor-pointer 
                                ${isDragging ? 'active-zone' : 'border-[#404040] hover-card'}`}
                            onClick={() => fileInputRef.current?.click()}
                            onDragOver={e => { e.preventDefault(); setIsDragging(true); }}
                            onDragLeave={() => setIsDragging(false)}
                            onDrop={e => { e.preventDefault(); setIsDragging(false); handleFiles(e.dataTransfer.files); }}
                        >
                            <input type="file" ref={fileInputRef} className="hidden" multiple accept=".xml,.zip" onChange={e => handleFiles(e.target.files)} />
                            
                            {processing ? (
                                <div className="flex flex-col items-center animate-pulse">
                                    <i data-lucide="binary" className="w-10 h-10 text-accent animate-spin mb-4"></i>
                                    <p className="text-sm font-mono text-accent">COMPILING...</p>
                                </div>
                            ) : (
                                <div className="space-y-4">
                                    <i data-lucide="code-2" className="w-10 h-10 text-[#505050] mx-auto"></i>
                                    <div>
                                        <p className="text-base text-[#bababa]">Drop Source Code (XML/ZIP)</p>
                                        <p className="text-[10px] text-[#606060] mt-2 uppercase tracking-widest font-mono">e-Gov Standard v5</p>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Terminal Log */}
                        <div className="mt-4 lichess-card p-3 font-mono text-[11px] text-[#606060] terminal-font h-32 overflow-hidden border border-[#303030]">
                            <div className="flex items-center space-x-2 mb-2 border-b border-[#303030] pb-1">
                                <div className="w-2 h-2 rounded-full bg-[#505050]"></div>
                                <div className="w-2 h-2 rounded-full bg-[#505050]"></div>
                                <span className="opacity-50">Output</span>
                            </div>
                            <div className="flex flex-col space-y-1">
                                {logs.length === 0 && <span className="opacity-30">Ready for input...</span>}
                                {logs.map((l, i) => (
                                    <div key={i} className="truncate flex items-center">
                                        <span className="text-accent mr-2">➜</span>
                                        <span className="opacity-80">{l}</span>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Footer Info */}
                        <div className="mt-4 flex justify-between items-center text-[10px] text-[#404040] font-mono">
                            <span>TARGET: NOTEBOOKLM / MD</span>
                            <span>BUILD: STABLE</span>
                        </div>

                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
