<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legal Compiler for AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Lichess / Dark Mode Theme */
        body { background-color: #161512; color: #bababa; font-family: 'Noto Sans JP', sans-serif; }
        .lichess-card { background-color: #262421; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .active-zone { background-color: #2b3036; border-color: #3692e7 !important; }
        .text-accent { color: #3692e7; }
        .border-accent { border-color: #3692e7; }
        .hover-card:hover { border-color: #606060; }
        
        /* Terminal / Log Styling */
        .terminal-font { font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Mono', 'Droid Sans Mono', 'Source Code Pro', monospace; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #161512; }
        ::-webkit-scrollbar-thumb { background: #404040; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #505050; }
    </style>
    <script>
        // TypeScript (TSX) 解析用のBabelプリセットを登録
        Babel.registerPreset('tsx', {
            presets: [
                [Babel.availablePresets['typescript'], { isTSX: true, allExtensions: true }],
                Babel.availablePresets['react']
            ]
        });
    </script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel" data-presets="tsx">
        const { useState, useEffect, useRef } = React;

        // グローバル変数の型宣言
        declare const JSZip: any;
        declare const lucide: any;

        interface ParsedDocument {
            title: string;
            content: string;
        }

        interface DocStats {
            part: number;
            chapter: number;
            section: number;
            article: number;
            paragraph: number;
            item: number;
        }

        // --- Helper: Encoding Detection & Reading ---
        const readFileAuto = async (file: File): Promise<string> => {
            const buffer = await file.arrayBuffer();
            try {
                const decoder = new TextDecoder("utf-8", { fatal: true });
                return decoder.decode(buffer);
            } catch (e) {
                try {
                    const decoder = new TextDecoder("shift-jis", { fatal: true });
                    return decoder.decode(buffer);
                } catch (e2) {
                    const decoder = new TextDecoder("utf-8");
                    return decoder.decode(buffer);
                }
            }
        };

        // --- Helper: Text Normalization ---
        const normalizeText = (str: string | null | undefined): string => {
            if (!str) return "";
            return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, (s: string) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
                      .replace(/\u3000/g, ' ')
                      .replace(/&nbsp;/g, ' ')
                      .trim();
        };

        // --- Helper: Kanji Number to Arabic Number ---
        const parseKanjiNum = (s: string | null | undefined): number | string => {
            if (!s) return "";
            // すでにアラビア数字の場合
            if (s.match(/^[0-9０-９]+$/)) {
                return s.replace(/[０-９]/g, (c: string) => String.fromCharCode(c.charCodeAt(0) - 0xFEE0));
            }
            // 漢数字の解析
            const map: Record<string, number> = {'〇':0,'一':1,'二':2,'三':3,'四':4,'五':5,'六':6,'七':7,'八':8,'九':9};
            const unit: Record<string, number> = {'十':10,'百':100,'千':1000};
            let res = 0;
            let tmp = 0;
            for(const char of s) {
                if(unit[char]) {
                    if(tmp === 0) tmp = 1;
                    res += tmp * unit[char];
                    tmp = 0;
                } else if (map[char] !== undefined) {
                    tmp = map[char];
                }
            }
            return res + tmp;
        };

        const extractAndConvertNum = (s: string | null | undefined): string => {
            if (!s) return "";
            const cleanStr = s.replace(/[第条項号]/g, '').trim();
            return parseKanjiNum(cleanStr).toString();
        };

        // --- Core Logic 1: XML Parsing (v5 Deep Structure) ---
        const ERA_MAP: Record<string, string> = { "Meiji": "明治", "Taisho": "大正", "Showa": "昭和", "Heisei": "平成", "Reiwa": "令和" };

        const parseLegalXML = (xmlText: string): ParsedDocument => {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            
            const lawTitle = normalizeText(xmlDoc.querySelector('LawTitle')?.textContent) || "Unknown_Law";
            const lawNum = normalizeText(xmlDoc.querySelector('LawNum')?.textContent) || "";
            
            let enactDate = "";
            const lawTag = xmlDoc.querySelector('Law');
            if (lawTag && lawTag.getAttribute('Era')) {
                const eraRaw = lawTag.getAttribute('Era')!;
                const era = ERA_MAP[eraRaw] || eraRaw;
                enactDate = `${era}${lawTag.getAttribute('Year')}年${lawTag.getAttribute('PromulgateMonth')}月${lawTag.getAttribute('PromulgateDay')}日公布`;
                enactDate = normalizeText(enactDate);
            }

            let mdBody = `# ${lawTitle}\n\n`;
            const stats: DocStats = { part: 0, chapter: 0, section: 0, article: 0, paragraph: 0, item: 0 };

            const clean = (t: string | null | undefined): string => t ? normalizeText(t.replace(/\s+/g, ' ')) : '';
            
            const getSiblingIndex = (node: Element, tag: string): number => {
                let count = 1;
                let prev = node.previousElementSibling;
                while(prev) { 
                    if(prev.nodeName === tag) count++; 
                    prev = prev.previousElementSibling; 
                }
                return count;
            };

            const traverse = (node: Element | null): void => {
                if (!node) return;
                const name = node.nodeName;

                if (name === 'Part') {
                    mdBody += `\n## ${normalizeText(node.querySelector('PartTitle')?.textContent)}\n\n`;
                    stats.part++;
                } else if (name === 'Chapter') {
                    mdBody += `\n### ${normalizeText(node.querySelector('ChapterTitle')?.textContent)}\n\n`;
                    stats.chapter++;
                } else if (name === 'Section') {
                    mdBody += `\n#### ${normalizeText(node.querySelector('SectionTitle')?.textContent)}\n\n`;
                    stats.section++;
                } else if (name === 'Article') {
                    const titleRaw = normalizeText(node.querySelector('ArticleTitle')?.textContent);
                    const num = extractAndConvertNum(titleRaw);
                    let caption = normalizeText(node.querySelector('ArticleCaption')?.textContent);
                    if (caption) caption = `(${caption})`;
                    mdBody += `\n##### 第${num}条 ${caption}\n`;
                    stats.article++;
                } else if (name === 'Paragraph') {
                    let numStr = normalizeText(node.querySelector('ParagraphNum')?.textContent);
                    const num = numStr ? extractAndConvertNum(numStr) : getSiblingIndex(node, 'Paragraph').toString();
                    const sentence = node.querySelector('ParagraphSentence > Sentence')?.textContent || '';
                    mdBody += `**第${num}項** ${clean(sentence)}\n\n`;
                    stats.paragraph++;
                } else if (name === 'Item') {
                    const titleRaw = normalizeText(node.querySelector('ItemTitle')?.textContent);
                    const num = extractAndConvertNum(titleRaw);
                    const sentence = node.querySelector('ItemSentence > Sentence')?.textContent || '';
                    mdBody += `- **第${num}号** ${clean(sentence)}\n`;
                    stats.item++;
                } else if (name === 'Subitem1') {
                    const num = extractAndConvertNum(normalizeText(node.querySelector('Subitem1Title')?.textContent));
                    const sentence = node.querySelector('Subitem1Sentence > Sentence')?.textContent || '';
                    mdBody += `  - **${num}** ${clean(sentence)}\n`; 
                } else if (name === 'Subitem2') {
                    const num = extractAndConvertNum(normalizeText(node.querySelector('Subitem2Title')?.textContent));
                    const sentence = node.querySelector('Subitem2Sentence > Sentence')?.textContent || '';
                    mdBody += `    - **${num}** ${clean(sentence)}\n`;
                }

                Array.from(node.children).forEach((child: Element) => {
                    const ignoreTags = [
                        'PartTitle', 'ChapterTitle', 'SectionTitle', 'ArticleTitle', 
                        'ArticleCaption', 'ParagraphNum', 'ParagraphSentence', 
                        'ItemTitle', 'ItemSentence', 'Subitem1Title', 'Subitem1Sentence', 
                        'Subitem2Title', 'Subitem2Sentence'
                    ];
                    if (!ignoreTags.includes(child.nodeName)) {
                        traverse(child);
                    }
                });
            };

            const mainProvision = xmlDoc.querySelector('MainProvision');
            if (mainProvision) traverse(mainProvision);

            const header = `---
title: "${lawTitle}"
law_num: "${lawNum}"
enact_date: "${enactDate}"
source_type: "xml_converted"
structure_summary:
  parts: ${stats.part}
  chapters: ${stats.chapter}
  sections: ${stats.section}
  articles: ${stats.article}
  items: ${stats.item}
---\n\n`;

            return { title: lawTitle, content: header + mdBody };
        };

        // --- Core Logic 2: Legacy HTML Parsing (Master Class) ---
        const parseReikiHTML = (htmlText: string): ParsedDocument => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlText, "text/html");
            const title = normalizeText(doc.querySelector('title')?.textContent) || "Unknown_Legacy_Law";
            
            let mdBody = `# ${title}\n\n`;
            const stats: DocStats = { part: 0, chapter: 0, section: 0, article: 0, paragraph: 0, item: 0 };

            const container = 
                doc.querySelector('.joubun') || 
                doc.querySelector('#primary') || 
                doc.querySelector('#main') || 
                doc.body;

            let lines: Element[] = [];
            const elines = container.querySelectorAll('.eline');
            if (elines.length > 0) {
                lines = Array.from(elines);
            } else {
                lines = Array.from(container.querySelectorAll('div, p')).filter(el => {
                    return el.childElementCount === 0 || ((el as HTMLElement).innerText && (el as HTMLElement).innerText.length < 200);
                });
            }

            lines.forEach((el: Element) => {
                const rawText = normalizeText(el.textContent);
                if (!rawText) return;

                // --- 1. Article (条) ---
                let match = rawText.match(/^[\(（](.+?)[\)）]\s*第([0-9０-９一-千]+)条[\s　]*(.*)/) || 
                            rawText.match(/^第([0-9０-９一-千]+)条[\s　]+[\(（](.+?)[\)）][\s　]*(.*)/);
                
                if (match) {
                    const isLegacyCaptionFirst = rawText.startsWith('(') || rawText.startsWith('（');
                    const num = isLegacyCaptionFirst ? parseKanjiNum(match[2]) : parseKanjiNum(match[1]);
                    const caption = isLegacyCaptionFirst ? `(${match[1]})` : `(${match[2]})`;
                    const content = match[3];
                    mdBody += `\n##### 第${num}条 ${caption}\n`;
                    if (content) mdBody += `${content}\n`; 
                    stats.article++;
                    return;
                }

                match = rawText.match(/^第([0-9０-９一-千]+)条[\s　]*(.*)/);
                if (match) {
                    const num = parseKanjiNum(match[1]);
                    const content = match[2];
                    mdBody += `\n##### 第${num}条\n`; 
                    if (content) mdBody += `${content}\n`;
                    stats.article++;
                    return;
                }
                
                // --- 2. Paragraph (項) ---
                if (rawText.match(/^[0-9]+[\s　]/)) {
                    const parts = rawText.split(/[\s　]/);
                    const num = parts[0];
                    const body = rawText.substring(num.length).trim();
                    if (!body.startsWith('年')) {
                        mdBody += `\n**第${num}項** ${body}\n`;
                        stats.paragraph++;
                        return;
                    }
                }

                // --- 3. Item (号) ---
                // 括弧書きの号数（例：(1), (一)）
                let itemMatch = rawText.match(/^[\(（]([0-9０-９一-千]+)[\)）][\s　]*(.*)/);
                if (itemMatch) {
                     const num = extractAndConvertNum(itemMatch[1]);
                     mdBody += `- **第${num}号** ${itemMatch[2] || rawText.substring(itemMatch[0].length).trim()}\n`;
                     stats.item++;
                     return;
                }

                // 明示的な第N号
                itemMatch = rawText.match(/^第([0-9０-９一-千]+)号[\s　]*(.*)/);
                if (itemMatch) {
                     const num = extractAndConvertNum(itemMatch[1]);
                     const content = itemMatch[2];
                     mdBody += `- **第${num}号** ${content}\n`;
                     stats.item++;
                     return;
                }
                
                // ア・イ・ウ（号の細分）
                if (rawText.match(/^[ア-ン][\s　]/)) {
                     mdBody += `- ${rawText}\n`;
                     return;
                }

                // --- 4. Fallback ---
                if (rawText !== title) {
                    mdBody += `${rawText}\n`;
                }
            });

            const header = `---
title: "${title}"
source_type: "legacy_html_converted"
description: "Converted from Reiki-Base/MHTML/HTML format"
structure_summary:
  articles: ${stats.article}
  items: ${stats.item}
---\n\n`;

            return { title, content: header + mdBody };
        };

        // --- UI Component ---
        const App: React.FC = () => {
            const [logs, setLogs] = useState<string[]>([]);
            const [processing, setProcessing] = useState<boolean>(false);
            const [downloadUrl, setDownloadUrl] = useState<string | null>(null);
            const [downloadName, setDownloadName] = useState<string>("");
            const [isDragging, setIsDragging] = useState<boolean>(false);
            const fileInputRef = useRef<HTMLInputElement>(null);

            const addLog = (msg: string) => setLogs(prev => [...prev.slice(-5), msg]);

            const handleFiles = async (fileList: FileList | null) => {
                if (!fileList || fileList.length === 0) return;
                
                setProcessing(true);
                setDownloadUrl(null); 
                setLogs([]);
                const outputZip = new JSZip();
                let processedCount = 0;

                try {
                    addLog("Initializing compiler...");
                    for (let i = 0; i < fileList.length; i++) {
                        const file = fileList[i];
                        const fname = file.name.toLowerCase();
                        
                        if (fname.endsWith('.zip')) {
                            addLog(`Reading archive: ${file.name}`);
                            const loadedZip = await JSZip.loadAsync(file);
                            const xmlFiles = Object.keys(loadedZip.files).filter(n => n.endsWith('.xml'));
                            for (const xmlPath of xmlFiles) {
                                const xmlText = await loadedZip.files[xmlPath].async("text");
                                const { title, content } = parseLegalXML(xmlText);
                                const safeName = title.replace(/[\\/:*?"<>|]/g, '_');
                                outputZip.file(`${safeName}.md`, content);
                                processedCount++;
                                addLog(`Compiled XML: ${title}`);
                            }
                        } else if (fname.endsWith('.xml')) {
                            const xmlText = await readFileAuto(file); 
                            const { title, content } = parseLegalXML(xmlText);
                            const safeName = title.replace(/[\\/:*?"<>|]/g, '_');
                            outputZip.file(`${safeName}.md`, content);
                            processedCount++;
                            addLog(`Compiled XML: ${title}`);

                        } else if (fname.endsWith('.html') || fname.endsWith('.htm')) {
                            addLog(`Reading Legacy HTML: ${file.name}`);
                            const rawText = await readFileAuto(file); 
                            
                            const { title, content } = parseReikiHTML(rawText);
                            const safeName = title.replace(/[\\/:*?"<>|]/g, '_');
                            outputZip.file(`${safeName}_legacy.md`, content);
                            processedCount++;
                            addLog(`Compiled Legacy: ${title}`);
                        }
                    }

                    if (processedCount > 0) {
                        addLog(`Building artifacts...`);
                        const contentBlob = await outputZip.generateAsync({ type: "blob" });
                        const url = URL.createObjectURL(contentBlob);
                        setDownloadUrl(url);
                        setDownloadName(`Legal_Artifacts_${new Date().toISOString().slice(0,10)}.zip`);
                        addLog("Build complete. Ready to download.");
                    } else {
                        addLog("Error: No valid sources found.");
                    }
                } catch (e: any) {
                    addLog(`Fatal Error: ${e.message}`);
                    console.error(e);
                } finally {
                    setProcessing(false);
                }
            };

            const reset = () => {
                setDownloadUrl(null);
                setLogs([]);
                if (fileInputRef.current) {
                    fileInputRef.current.value = "";
                }
            };

            useEffect(() => { lucide.createIcons(); }, [logs, downloadUrl, processing]);

            const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
                e.preventDefault();
                setIsDragging(true);
            };

            const handleDragLeave = () => {
                setIsDragging(false);
            };

            const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
                e.preventDefault();
                setIsDragging(false);
                if (e.dataTransfer.files) {
                    handleFiles(e.dataTransfer.files);
                }
            };

            const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
                if (e.target.files) {
                    handleFiles(e.target.files);
                }
            };

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-6">
                    <div className="w-full max-w-lg">
                        
                        {/* Header */}
                        <header className="flex items-center space-x-3 mb-6 select-none opacity-90">
                            <i data-lucide="cpu" className="w-6 h-6 text-accent"></i>
                            <h1 className="text-xl font-light tracking-wide text-[#bababa]">Legal <span className="text-accent font-normal">Compiler</span></h1>
                        </header>

                        {/* Main Interaction Area */}
                        {!downloadUrl ? (
                            <div 
                                className={`lichess-card p-12 text-center border-2 border-dashed transition-all duration-200 cursor-pointer 
                                    ${isDragging ? 'active-zone' : 'border-[#404040] hover-card'}`}
                                onClick={() => !processing && fileInputRef.current?.click()}
                                onDragOver={handleDragOver}
                                onDragLeave={handleDragLeave}
                                onDrop={handleDrop}
                            >
                                <input 
                                    type="file" 
                                    ref={fileInputRef} 
                                    className="hidden" 
                                    multiple 
                                    accept=".xml,.zip,.html,.htm" 
                                    onChange={handleFileInputChange} 
                                />
                                
                                {processing ? (
                                    <div className="flex flex-col items-center animate-pulse">
                                        <i data-lucide="binary" className="w-10 h-10 text-accent animate-spin mb-4"></i>
                                        <p className="text-sm font-mono text-accent">COMPILING...</p>
                                    </div>
                                ) : (
                                    <div className="space-y-4">
                                        <i data-lucide="code-2" className="w-10 h-10 text-[#505050] mx-auto"></i>
                                        <div>
                                            <p className="text-base text-[#bababa]">Drop Source Code</p>
                                            <p className="text-[10px] text-[#606060] mt-2 uppercase tracking-widest font-mono">
                                                XML (v5) / ZIP / HTML (Legacy)
                                            </p>
                                        </div>
                                    </div>
                                )}
                            </div>
                        ) : (
                            // Download View
                            <div className="lichess-card p-8 text-center border border-[#303030] animate-fade-in">
                                <div className="mb-6 flex justify-center">
                                    <div className="w-16 h-16 rounded-full bg-[#2b3036] flex items-center justify-center border border-[#3692e7]">
                                        <i data-lucide="check" className="w-8 h-8 text-accent"></i>
                                    </div>
                                </div>
                                <h2 className="text-lg text-[#bababa] mb-2">Compilation Complete</h2>
                                <p className="text-xs text-[#606060] mb-6 font-mono">Ready to export artifacts.</p>
                                
                                <div className="flex space-x-3 justify-center">
                                    <a 
                                        href={downloadUrl} 
                                        download={downloadName}
                                        className="bg-[#3692e7] hover:bg-[#2b7bc4] text-white px-6 py-2 rounded text-sm font-medium transition-colors flex items-center"
                                    >
                                        <i data-lucide="download" className="w-4 h-4 mr-2"></i>
                                        Download ZIP
                                    </a>
                                    <button 
                                        onClick={reset}
                                        className="bg-[#303030] hover:bg-[#404040] text-[#bababa] px-4 py-2 rounded text-sm transition-colors"
                                    >
                                        Reset
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* System Log */}
                        <div className="mt-4 lichess-card p-3 font-mono text-[11px] text-[#606060] terminal-font h-32 overflow-hidden border border-[#303030]">
                            <div className="flex items-center space-x-2 mb-2 border-b border-[#303030] pb-1">
                                <div className="w-2 h-2 rounded-full bg-[#505050]"></div>
                                <div className="w-2 h-2 rounded-full bg-[#505050]"></div>
                                <span className="opacity-50">System Log</span>
                            </div>
                            <div className="flex flex-col space-y-1">
                                {logs.length === 0 && <span className="opacity-30">Ready for input...</span>}
                                {logs.map((l, i) => (
                                    <div key={i} className="truncate flex items-center">
                                        <span className="text-accent mr-2">➜</span>
                                        <span className="opacity-80">{l}</span>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Footer Info */}
                        <div className="mt-4 flex justify-between items-center text-[10px] text-[#404040] font-mono">
                            <span>TARGET: NOTEBOOKLM / MD</span>
                            <span>BUILD: STABLE + LEGACY (HTML)</span>
                        </div>

                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
        root.render(<App />);
    </script>
</body>
</html>
